"""GraphQL schema for SoroScan API using Strawberry."""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Optional

import strawberry
import strawberry_django
from strawberry import auto
from strawberry.types import Info

from .models import ContractEvent, TrackedContract
from .services.timeline import build_timeline


@strawberry_django.type(TrackedContract)
class ContractType:
    id: auto
    contract_id: auto
    name: auto
    description: auto
    is_active: auto
    created_at: auto

    @strawberry.field
    def event_count(self) -> int:
        return self.events.count()


@strawberry_django.type(ContractEvent)
class EventType:
    id: auto
    event_type: auto
    payload: strawberry.scalars.JSON
    payload_hash: auto
    ledger: auto
    event_index: auto
    timestamp: auto
    tx_hash: auto
    schema_version: auto
    validation_status: auto

    @strawberry.field
    def contract_id(self) -> str:
        return self.contract.contract_id

    @strawberry.field
    def contract_name(self) -> str:
        return self.contract.name


@strawberry.type
class ContractStats:
    contract_id: str
    name: str
    total_events: int
    unique_event_types: int
    last_activity: Optional[datetime]


@strawberry.type
class EventTypeCount:
    event_type: str
    count: int


@strawberry.enum
class TimelineBucketSize(Enum):
    FIVE_MINUTES = "FIVE_MINUTES"
    THIRTY_MINUTES = "THIRTY_MINUTES"
    ONE_HOUR = "ONE_HOUR"
    ONE_DAY = "ONE_DAY"


BUCKET_SECONDS_BY_SIZE = {
    TimelineBucketSize.FIVE_MINUTES: 300,
    TimelineBucketSize.THIRTY_MINUTES: 1800,
    TimelineBucketSize.ONE_HOUR: 3600,
    TimelineBucketSize.ONE_DAY: 86_400,
}


@strawberry.type
class EventTimelineGroup:
    start: datetime
    end: datetime
    event_count: int
    event_type_counts: list[EventTypeCount]
    events: list[EventType]


@strawberry.type
class EventTimelineResult:
    contract_id: str
    bucket_size: TimelineBucketSize
    since: datetime
    until: datetime
    total_events: int
    groups: list[EventTimelineGroup]


@strawberry.type
class Query:
    @strawberry.field
    def contracts(self, is_active: Optional[bool] = None) -> list[ContractType]:
        """Get all tracked contracts."""
        qs = TrackedContract.objects.all()
        if is_active is not None:
            qs = qs.filter(is_active=is_active)
        return qs

    @strawberry.field
    def contract(self, contract_id: str) -> Optional[ContractType]:
        """Get a specific contract by ID."""
        try:
            return TrackedContract.objects.get(contract_id=contract_id)
        except TrackedContract.DoesNotExist:
            return None

    @strawberry.field
    def events(
        self,
        contract_id: Optional[str] = None,
        event_type: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
        since: Optional[datetime] = None,
        until: Optional[datetime] = None,
    ) -> list[EventType]:
        """Query events with flexible filtering."""
        qs = ContractEvent.objects.all()

        if contract_id:
            qs = qs.filter(contract__contract_id=contract_id)
        if event_type:
            qs = qs.filter(event_type=event_type)
        if since:
            qs = qs.filter(timestamp__gte=since)
        if until:
            qs = qs.filter(timestamp__lte=until)

        limit = min(limit, 1000)
        return qs[offset : offset + limit]

    @strawberry.field
    def event(self, id: int) -> Optional[EventType]:
        """Get a specific event by ID."""
        try:
            return ContractEvent.objects.get(id=id)
        except ContractEvent.DoesNotExist:
            return None

    @strawberry.field
    def contract_stats(self, contract_id: str) -> Optional[ContractStats]:
        """Get aggregate statistics for a contract."""
        try:
            contract = TrackedContract.objects.get(contract_id=contract_id)
        except TrackedContract.DoesNotExist:
            return None

        from django.db.models import Count, Max

        stats = contract.events.aggregate(
            total=Count("id"),
            unique_types=Count("event_type", distinct=True),
            last=Max("timestamp"),
        )

        return ContractStats(
            contract_id=contract.contract_id,
            name=contract.name,
            total_events=stats["total"] or 0,
            unique_event_types=stats["unique_types"] or 0,
            last_activity=stats["last"],
        )

    @strawberry.field
    def event_types(self, contract_id: str) -> list[str]:
        """Get all unique event types for a contract."""
        return list(
            ContractEvent.objects.filter(contract__contract_id=contract_id)
            .values_list("event_type", flat=True)
            .distinct()
        )

    @strawberry.field
    def event_timeline(
        self,
        contract_id: str,
        bucket_size: TimelineBucketSize = TimelineBucketSize.THIRTY_MINUTES,
        event_types: Optional[list[str]] = None,
        since: Optional[datetime] = None,
        until: Optional[datetime] = None,
        timezone: str = "UTC",
        limit_groups: int = 500,
        include_events: bool = True,
    ) -> EventTimelineResult:
        """Return grouped timeline data for contract event history."""
        bucket_seconds = BUCKET_SECONDS_BY_SIZE[bucket_size]
        timeline = build_timeline(
            contract_id=contract_id,
            bucket_seconds=bucket_seconds,
            event_types=event_types,
            since=since,
            until=until,
            timezone_name=timezone,
            limit_groups=limit_groups,
            include_events=include_events,
        )

        groups = [
            EventTimelineGroup(
                start=group.start,
                end=group.end,
                event_count=group.event_count,
                event_type_counts=[
                    EventTypeCount(event_type=item.event_type, count=item.count)
                    for item in group.event_type_counts
                ],
                events=group.events,
            )
            for group in timeline.groups
        ]

        return EventTimelineResult(
            contract_id=timeline.contract_id,
            bucket_size=bucket_size,
            since=timeline.since,
            until=timeline.until,
            total_events=timeline.total_events,
            groups=groups,
        )


@strawberry.type
class Mutation:
    @strawberry.mutation
    def register_contract(
        self,
        info: Info,
        contract_id: str,
        name: str,
        description: str = "",
    ) -> ContractType:
        """Register a new contract for indexing."""
        contract = TrackedContract.objects.create(
            contract_id=contract_id,
            name=name,
            description=description,
            owner_id=1,
        )
        return contract

    @strawberry.mutation
    def update_contract(
        self,
        info: Info,
        contract_id: str,
        name: Optional[str] = None,
        description: Optional[str] = None,
        is_active: Optional[bool] = None,
    ) -> Optional[ContractType]:
        """Update a tracked contract."""
        try:
            contract = TrackedContract.objects.get(contract_id=contract_id)
        except TrackedContract.DoesNotExist:
            return None

        if name is not None:
            contract.name = name
        if description is not None:
            contract.description = description
        if is_active is not None:
            contract.is_active = is_active

        contract.save()
        return contract


schema = strawberry.Schema(query=Query, mutation=Mutation)
